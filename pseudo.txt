SelectionSort(A):
    for i = 0 to length(A) - 1:
        minIndex = i
        for j = i + 1 to length(A):
            if A[j] < A[minIndex]:
                minIndex = j
        swap A[i] and A[minIndex]



InsertionSort(A):
    for i = 1 to length(A) - 1:
        key = A[i]
        j = i - 1
        while j >= 0 and A[j] > key:
            A[j + 1] = A[j]
            j = j - 1
        A[j + 1] = key



MergeSort(A):
    if length(A) > 1:
        mid = length(A) // 2
        left = A[0...mid]
        right = A[mid+1...end]

        MergeSort(left)
        MergeSort(right)

        Merge(left, right, A)

Merge(left, right, A):
    i = 0, j = 0, k = 0
    while i < length(left) and j < length(right):
        if left[i] < right[j]:
            A[k] = left[i]
            i = i + 1
        else:
            A[k] = right[j]
            j = j + 1
        k = k + 1

    while i < length(left):
        A[k] = left[i]
        i = i + 1
        k = k + 1

    while j < length(right):
        A[k] = right[j]
        j = j + 1
        k = k + 1



QuickSort(A, low, high):
    if low < high:
        pivot = Partition(A, low, high)
        QuickSort(A, low, pivot - 1)
        QuickSort(A, pivot + 1, high)

Partition(A, low, high):
    pivot = A[high]
    i = low - 1
    for j = low to high - 1:
        if A[j] < pivot:
            i = i + 1
            swap A[i] and A[j]
    swap A[i + 1] and A[high]
    return i + 1



BFS(graph, start):
    create a queue Q
    create a set visited
    enqueue start into Q
    add start to visited
    
    while Q is not empty:
        node = dequeue from Q
        visit(node)
        
        for each neighbor of node:
            if neighbor not in visited:
                enqueue neighbor into Q
                add neighbor to visited



DFS(graph, node, visited):
    visit(node)
    add node to visited
    
    for each neighbor of node:
        if neighbor not in visited:
            DFS(graph, neighbor, visited)



DFS(graph, start):
    create a stack S
    create a set visited
    push start into S
    add start to visited
    
    while S is not empty:
        node = pop from S
        visit(node)
        
        for each neighbor of node:
            if neighbor not in visited:
                push neighbor into S
                add neighbor to visited